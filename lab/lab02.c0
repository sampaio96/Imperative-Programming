//Task 1.1.

//x has not changed, it keeps 4


//Task 1.2. 

//1st time: e = 1
//2nd time: e = 2
//3rd time: e = 4
//3th time: e = 8
//ans: 4 times


//Task 3.1.

int fact(int n) {
  int i = 1;
  int product_for_now = 1;

  while (i <= n) {
  product_for_now = product_for_now * i;
  i ++;
  }

return product_for_now;

}


//Task 4.1.

//A[0], A[1] and A[2] have default values of 0
//Trying to access A[3] results in an error


//Task 4.2.

int mult_array(int[] A, int length) {

  int i = 0;
  int product = 1;

  while (i < length) {
  product = product * A[i];
  i ++;

  }

return product;

}


//Task 4.3.

void addOne(int[] A, int length) {
  
  int i = 0;

  while (i < length) {
  A[i] = A[i] + 1;
  i ++;

  }
}


//Task 4.4.

int[] increasing(int n) {
  int i = 0;
  int[] b = alloc_array(int,n);
  
  while (i < n) {
  b[i]=i;
  i++;
  }
  return b;
}


//Task 4.5.

//Contrary to what happens with int, arrays do not create new "boxes", but rather link the existent in case of a similar situtation happens (e.g. A[]=B[])


//Task 4.6.

int[] addOneCopy(int[] arr, int size) {
  
  int i = 0;
  int[] arrCopy = alloc_array(int,size);

  while (i < size) {
  arrCopy[i] = arr[i] + 1;
  i ++;

  }

return arrCopy;

}





/*
int sum(int n) 
{
  int s = 1;

  int i = 0;
  while (i <= n) {
    s = s + i;
    i = i + 1;
  }

  return s;
}

int sum_array(int[] A, int length)
{
  int s = 0;

  int i = 0;
  while (i < length)
    {
      s = A[i] + s;  
      i = i + 1;
    }
  return s;
}
*/